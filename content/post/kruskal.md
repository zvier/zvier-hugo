---
title: "kruskal算法"
date: 2019-10-19T17:15:57+08:00
draft: true
categories: ["技术"]
tags: ["算法"]
---
曾以为走不出的日子，现在都回不去了。——村上春树
<!--more-->
# 算法简介
能产生最小生成树的另外一个算法是kruskal算法，和prim算法一样，它也是一个贪婪算法。  
kruskal算法将加权连通图G=<V, E>的最小生成树看作是一个具有|V|-1条边的无环子图，且边的权重总和是最小的。因此，kruskal通过以边为操作对象，对子图进行一系列的扩展，也能构造出一颗最小生成树，只是在算法的中间阶段，整个子图不一定是连通的。

# 算法描述
假设给定的图有m个节点，n条边:算法开始如下:  
1. 把m个节点看成m颗独立的生成树，然后我们先把图中的n条边按权重非递减顺序进行排序，这和对待硬币找零问题一样，会对硬币面额心里排个序。
2. 接下来从一个空子图开始，依次扫描边的有序列表，并把列表中的下一条边加到当前子图中  
3. 如果边的两个节点分别位于两颗树上，就把两颗树合并成一颗树  
3. 如果边的两个节点位于同一颗树上，那就忽略这条边，因为这个添加会产生回路
这样，等待所有的边遍历结束，如果所有的生成树可以合并成一颗生成树，那就是我们要找的最小生成树，反之没有最小生成树。  

# 算法
{{< highlight go "linenos=inline" >}}
Krukal(G)
{{< /highlight >}}

# kruskal与prim算法比较
类似prim算法，我们也能够证明kruskal算法的正确性，prim算法中，Et是一颗树，kruskal算法中，仅仅是一个无环子图。kruskal算法再每一次迭代时，必须对下一条将要扩展纳入的边检查是否会造成回路。当且仅当新的边所连接的两个顶点之间已经有一条路径时才会形成一条新的回路。

总之，prim算法是以点为对象，挑选与当前树最短的点生成新的生成树，最终构成最小生成树。而kruskal算法则是以边为对象，不断加入新的且不构成环路的最短边来构成最小生成树  

