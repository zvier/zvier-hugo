---
title: "prim算法"
date: 2019-10-18T21:17:41+08:00
draft: true
categories: ["技术"]
tags: ["算法"]
---
醉后不知天在水，满船清梦压星河。——唐温如·《题龙阳县青草湖》
<!--more-->
# 问题
给定n个点，用一种成本最低的方式连接，使得每一对点之间都有一条路径。如果用图中的顶点来表示这些点，图中的边表示可能的连接，边的权重表示连接的成本，那该问题就是最小生成树问题。  

在实际中，给定n个城市，要在各个城市之间建立互联通信网，如和使得要铺设的通信电缆总长最小，这就是一个求最小生成树的应用问题。

# 连通图的生成树  
连通图的生成树首先是一颗树，也是该图的子图，无环连通了图的所有顶点。加权连通图的最小生成树则是图的一颗权重最小的生成树，树的权重即所有边的权重之和。

# prim算法
prim算法通过一系列不断扩张的子树来构造一颗最小生成树。从图的顶点集合V中任意选择一个顶点，作为序列中的初始子树，每次迭代是都以贪婪的方式来扩张当前生成的子树，把还不在树中的顶点添加到树中。

这里的贪婪扩张体现在: 1. 将要被新添加到树中的顶点当前还不在树中。2.
该顶点离当前树最近，即权重最小。

当图中所有顶点都在树中时，算法停止。由于每次迭代可以为树扩张一个顶点，总的迭代次数就是n-1。  

# 伪代码
{{< highlight bash "linenos=inline" >}}
Prim(G):
    // 输入: 加权连通图G=<V, E>
    // 输出: Et, 构成最小生成树的边集合
    Vt <- {v0}  // 选择任意顶点初始化树的顶点集合
    Et <- ∅
    for i<-1 to (|V| -1); do
        在所有边(v, u)中，选择权重最小的边e=(v, u)， 其中v已经在Vt中，而u在V-Vt中
        将顶点u加入到Vt
        将边e加入到Et
    done
    return Et
{{< /highlight >}}

# 算法证明
我们知道，并不是所有贪婪都能得到最优，那prim算法是不是最优呢？可以如下归纳证明:  
1. 设Prim算法生成的每一个子树为Ti, i=0, 1, ..., n-1。Tn-1即要求的最小生成树
2. T0只包含一个独立顶点，根据定义必然是最小生成树的一部分  
3. 假设Ti-1是最小生成树的一部分，需要证明prim算法从Ti-1扩展到的Ti也会是最小生成树的一部分  

接着反证，我们假设Ti不是最小生成树的一部分会发生什么事情呢
5. 设ei=(v, u)是从Ti-1树中一个顶点到还不在Ti-1中的一个顶点的权重最小的边，prim算法会选择用它来扩张Ti-1到Ti，并把边ei纳入到自己的扩张版图
6. 由于已经假设Ti不是最小生成树的一部分，但Ti-1是最小生成树的一部分，那真正的最小生成树必然是走另外一条路径e'=(v', u')发展，最后将顶点u通过e=(v, u)纳入版图，这颗最小生成树会和上面扩展出的生成树Ti可以构成一个环  
7. 此时，如果我们将边e'=(v', u')删掉，可以得到另一颗生成树，且由于ei<e'，这颗生成树就是一颗最小生成树，比通过走另一条路径得到的最小生成树还小   
8. 这和假设Ti不是最小生成树的一部分矛盾  

以上反正可以简单描述为:
假设权重最小的边不在最小生成树中，那将该边加入到最小生成树，必然形成回路，断掉回路中连接这两个顶点中较大的边，会得到一颗更小的最小生成树。与权重最小的边在最小生成树的假设矛盾。 


# 总结
prim算法正是通过贪婪地把离当前树最近地顶点纳入进来，最终形成了一颗最小生成树，步步为赢，终身为赢。值得注意地是这里地最小生成树不是唯一的，prim算法在遇到多个相同权重的边时，由于选边的方向不同，那最终最小生成树的形状也会有差异。

# 参考
1. 《算法设计与分析基础》


